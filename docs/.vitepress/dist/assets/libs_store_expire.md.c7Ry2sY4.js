import{_ as e,c as o,o as c,a5 as d}from"./chunks/framework.BhjPWYS5.js";const m=JSON.parse('{"title":"过期策略","description":"","frontmatter":{},"headers":[],"relativePath":"libs/store/expire.md","filePath":"libs/store/expire.md"}'),t={name:"libs/store/expire.md"},l=d('<h1 id="过期策略" tabindex="-1">过期策略 <a class="header-anchor" href="#过期策略" aria-label="Permalink to &quot;过期策略&quot;">​</a></h1><p>在 Redis 等内存数据库中，通常会有三种过期策略：</p><div class="tip custom-block"><p class="custom-block-title">定时删除</p><p>在设置 <code>key</code> 的过期时间的同时，为该 <code>key</code> 创建一个定时器，让定时器在 <code>key</code> 的过期时间来临时，对 <code>key</code> 进行删除。</p><ul><li>优点：保证内存被尽快释放</li><li>缺点：若过期 <code>key</code> 很多，删除这些 <code>key</code> 会占用很多的CPU时间，在CPU时间紧张的情况下，CPU不能把所有的时间用来做要紧的事儿，还需要去花时间删除这些 <code>key</code>。</li></ul></div><div class="tip custom-block"><p class="custom-block-title">惰性删除</p><p><code>key</code> 过期的时候不删除， 每次从数据库获取 <code>key</code> 的时候去检查是否过期，若过期，则删除，返回 <code>null</code>。</p><ul><li>优点：删除操作只发生在从数据库取出 <code>key</code> 的时候发生，而且只删除当前 <code>key</code> ，所以对CPU时间的占用是比较少的，而且此时的删除是已经到了非做不可的地步（如果此时还不删除的话，我们就会获取到了已经过期的 <code>key</code> 了）。</li><li>缺点：若大量的 <code>key</code> 在超出超时时间后，很久一段时间内，都没有被获取过，那么可能发生内存泄露（无用的垃圾占用了大量的内存）。</li></ul></div><div class="tip custom-block"><p class="custom-block-title">定期删除</p><p>每隔一段时间执行一次删除过期 <code>key</code> 操作。</p><ul><li>优点：通过限制删除操作的时长和频率，来减少删除操作对 CPU 时间的占用——处理&quot;定时删除&quot;的缺点，定期删除过期 <code>key</code> ——处理“惰性删除”的缺点。</li><li>缺点：在内存友好方面，不如“定时删除”，在 CPU 时间友好方面，不如“惰性删除”。 难点是合理设置删除操作的执行时长（每次删除执行多长时间）和执行频率（每隔多长时间做一次删除）（这个要根据服务器运行情况来定了）。</li></ul></div><p><code>StoreLib</code> 则采用惰性删除策略+初始化检查策略。</p><p>在对数据读写前检查是否过期，一方面避免了定期删除和定时删除设置定时器对 CPU 资源的占用，另一方面，用户端不需要像服务端那样缓存庞大的数据，因此惰性删除导致的内存资源占用也不会过多。同时，在模块初始化时对所有健进行检查，删除持久化过期数据，有效确保了设置过期时间的持久化数据不会占用过多存储空间。</p>',7),i=[l];function s(a,p,r,_,k,n){return c(),o("div",null,i)}const y=e(t,[["render",s]]);export{m as __pageData,y as default};
