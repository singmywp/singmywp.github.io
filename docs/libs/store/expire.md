# 过期策略

在 Redis 等内存数据库中，通常会有三种过期策略：

::: tip 定时删除

在设置 `key` 的过期时间的同时，为该 `key` 创建一个定时器，让定时器在 `key` 的过期时间来临时，对 `key` 进行删除。

- 优点：保证内存被尽快释放
- 缺点：若过期 `key` 很多，删除这些 `key` 会占用很多的CPU时间，在CPU时间紧张的情况下，CPU不能把所有的时间用来做要紧的事儿，还需要去花时间删除这些 `key`。

:::

::: tip 惰性删除

`key` 过期的时候不删除， 每次从数据库获取 `key` 的时候去检查是否过期，若过期，则删除，返回 `null`。

- 优点：删除操作只发生在从数据库取出 `key` 的时候发生，而且只删除当前 `key` ，所以对CPU时间的占用是比较少的，而且此时的删除是已经到了非做不可的地步（如果此时还不删除的话，我们就会获取到了已经过期的 `key` 了）。
- 缺点：若大量的 `key` 在超出超时时间后，很久一段时间内，都没有被获取过，那么可能发生内存泄露（无用的垃圾占用了大量的内存）。

:::

::: tip 定期删除

每隔一段时间执行一次删除过期 `key` 操作。

- 优点：通过限制删除操作的时长和频率，来减少删除操作对 CPU 时间的占用——处理"定时删除"的缺点，定期删除过期 `key` ——处理“惰性删除”的缺点。
- 缺点：在内存友好方面，不如“定时删除”，在 CPU 时间友好方面，不如“惰性删除”。
   难点是合理设置删除操作的执行时长（每次删除执行多长时间）和执行频率（每隔多长时间做一次删除）（这个要根据服务器运行情况来定了）。

:::

`StoreLib` 则采用惰性删除策略+初始化检查策略。

在对数据读写前检查是否过期，一方面避免了定期删除和定时删除设置定时器对 CPU 资源的占用，另一方面，用户端不需要像服务端那样缓存庞大的数据，因此惰性删除导致的内存资源占用也不会过多。同时，在模块初始化时对所有健进行检查，删除持久化过期数据，有效确保了设置过期时间的持久化数据不会占用过多存储空间。